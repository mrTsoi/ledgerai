import fs from 'node:fs/promises'
import path from 'node:path'
import { loadPentestConfig } from './_config.mjs'

function groupBy(list, keyFn) {
  const m = new Map()
  for (const item of list) {
    const k = keyFn(item)
    if (!m.has(k)) m.set(k, [])
    m.get(k).push(item)
  }
  return m
}

function mdEscape(s) {
  return String(s).replace(/</g, '&lt;').replace(/>/g, '&gt;')
}

function renderEndpointChecklist(ep) {
  const methods = ep.methods.length ? ep.methods.join(', ') : 'UNKNOWN'
  const access = (ep.expectedAccess || 'protected').toUpperCase()
  const accessNote = access === 'MIXED'
    ? 'MIXED (public without tenant_id; protected with tenant_id)'
    : access

  const accessLines = [
    `  - Expected access: ${accessNote}`,
  ]

  if (ep.expectedAccess === 'public' || ep.expectedAccess === 'mixed') {
    accessLines.push('  - Public data: verify only non-sensitive, non-tenant data is exposed')
    accessLines.push('  - Abuse controls: verify rate limiting / anti-enumeration as appropriate')
  }

  if (ep.expectedAccess === 'webhook') {
    accessLines.push('  - Webhook auth: signature/secret required; failures have zero side effects')
    accessLines.push('  - Idempotency: replay does not create duplicates')
  }

  return [
    `- **${mdEscape(ep.apiPath)}** (${methods})`,
    ...accessLines,
    `  - Auth: unauthenticated request is rejected (no 2xx) unless endpoint is explicitly public/webhook`,
    `  - AuthZ: role-based access enforced server-side (UI-only hiding is insufficient)`,
    `  - Tenancy: cannot access/modify other-tenant resources (IDOR/RLS)`,
    `  - Input: invalid/missing params return safe 4xx without stack traces`,
    `  - Errors/logs: responses and logs contain no secrets/PII`,
  ].join('\n')
}

function renderModuleHeader(moduleName) {
  const title = moduleName
    .split('-')
    .map((p) => p.charAt(0).toUpperCase() + p.slice(1))
    .join(' ')
  return `## ${title} Module\n`
}

function baseChecklistSections(config) {
  const baseUrl = config.target.baseUrl
  const name = config.target.name
  const generatedAt = new Date().toISOString()

  return `# LedgerAI Pentest Checklist (Generated)\n\n` +
    `**Target:** ${mdEscape(name)} — ${mdEscape(baseUrl)}\n\n` +
    `**Generated:** ${generatedAt}\n\n` +
    `## Rules of engagement\n` +
    `- Confirm written authorization for this target\n` +
    `- Use synthetic data only (no customer PII)\n` +
    `- Prefer staging; avoid disruptive volume\n` +
    `- Capture evidence for every finding\n\n` +
    `## Evidence template\n` +
    `- Test ID:\n` +
    `- Actor (tenant/user/role):\n` +
    `- Endpoint / action:\n` +
    `- Expected:\n` +
    `- Actual:\n` +
    `- Evidence (redacted):\n` +
    `- Impact:\n` +
    `- Recommendation:\n\n` +
    `## Global controls (apply to all modules)\n` +
    `- Authentication: session/JWT validation, logout invalidation, reset flows\n` +
    `- Authorization: RBAC enforcement, SUPER_ADMIN isolation\n` +
    `- Multi-tenancy: Supabase RLS + storage isolation + join leakage checks\n` +
    `- Web security: CSRF (where applicable), CORS, security headers, error hygiene\n` +
    `- Secrets: no service role key in client/build/logs\n` +
    `- Integrations: webhook signature verification + idempotency\n` +
    `- Availability: rate limiting/backpressure on auth + AI processing\n\n`
}

async function main() {
  const config = await loadPentestConfig()

  const inventoryPath = path.resolve(config.output.inventoryPath)
  const checklistPath = path.resolve(config.output.checklistPath)

  const inventoryRaw = await fs.readFile(inventoryPath, 'utf8')
  const inventory = JSON.parse(inventoryRaw)

  let md = baseChecklistSections(config)

  // Access classification summary
  if (config.scope.includeApi) {
    const eps = inventory.endpoints ?? []
    const publicish = eps.filter((e) => ['public', 'webhook', 'mixed'].includes(e.expectedAccess))
    md += `## Expected unauthenticated reachability (API)\n`
    md += `These endpoints are expected to be reachable without a user session (either truly public, webhook-authenticated, or mixed).\n\n`
    for (const e of publicish) {
      const why = Array.isArray(e.reasons) && e.reasons.length ? ` — ${e.reasons.join('; ')}` : ''
      md += `- ${mdEscape(e.apiPath)} [${mdEscape(e.expectedAccess)}]${mdEscape(why)}\n`
    }
    md += `\n`
  }

  if (config.scope.includeUiModules) {
    md += `## UI modules\n`
    for (const m of inventory.uiModules ?? []) {
      md += `- ${mdEscape(m)}\n`
    }
    md += `\n`
  }

  if (config.scope.includeApi) {
    const endpoints = inventory.endpoints ?? []
    const grouped = groupBy(endpoints, (e) => e.module || 'unknown')

    md += `# API modules\n\n`

    for (const [moduleName, eps] of [...grouped.entries()].sort((a, b) => a[0].localeCompare(b[0]))) {
      md += renderModuleHeader(moduleName)
      md += `### Endpoints\n`
      for (const ep of eps) md += renderEndpointChecklist(ep) + '\n'

      md += `\n### Module-specific focus\n`
      if (moduleName === 'admin') {
        md += `- Verify SUPER_ADMIN-only access (UI + API)\n- Verify audit logs for admin actions\n- Verify no cross-tenant enumeration\n\n`
      } else if (moduleName === 'webhooks') {
        md += `- Verify signature required and failures have no side effects\n- Verify replay/idempotency behavior\n- Verify metadata is validated server-side\n\n`
      } else if (moduleName === 'documents') {
        md += `- Verify storage RLS (download/upload) per tenant\n- Verify document processing cannot be triggered cross-tenant\n- Verify extracted data does not leak across tenants\n\n`
      } else if (moduleName === 'bank-feeds' || moduleName === 'banking') {
        md += `- Verify API keys/token exchange routes are protected\n- Verify webhook endpoints validate source and are idempotent\n- Verify reconciliation endpoints enforce tenant scope\n\n`
      } else if (moduleName === 'external-sources') {
        md += `- Verify OAuth callbacks validate state and redirect safety\n- Verify connector configs are tenant-scoped\n- Verify cron/rotate endpoints are admin/service protected\n\n`
      } else if (moduleName === 'subscription' || moduleName === 'stripe' || moduleName === 'subscriptions') {
        md += `- Verify checkout/session creation is authorized and tenant-scoped\n- Verify subscription state updates cannot be forged\n- Verify pricing/public endpoints expose only intended data\n\n`
      } else if (moduleName === 'ai') {
        md += `- Verify AI config access is tenant-scoped\n- Verify prompts/logs do not contain secrets/PII\n- Verify rate limits/backpressure for AI processing\n\n`
      } else {
        md += `- Verify authz and tenant isolation for all resource IDs\n- Verify errors are safe and logs are redacted\n\n`
      }
    }
  }

  if (config.scope.includeSupabase) {
    md += `# Supabase / Database\n\n`
    md += `## Tables (RLS must be validated)\n`
    for (const t of inventory.supabase?.tables ?? []) {
      md += `- ${mdEscape(t)}: cross-tenant read/write denied; no join leakage\n`
    }
    md += `\n## Functions/RPC\n`
    for (const fn of inventory.supabase?.functions ?? []) {
      md += `- ${mdEscape(fn)}: enforces tenant + role checks; no elevated definer surprises\n`
    }
    md += `\n`
  }

  await fs.mkdir(path.dirname(checklistPath), { recursive: true })
  await fs.writeFile(checklistPath, md, 'utf8')
  console.log(`Wrote checklist: ${path.relative(process.cwd(), checklistPath)}`)
}

main().catch((e) => {
  console.error(e)
  process.exit(1)
})
