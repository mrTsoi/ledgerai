import fs from 'node:fs/promises'
import path from 'node:path'
import { loadPentestConfig } from './_config.mjs'

async function walk(dir) {
  const out = []
  const entries = await fs.readdir(dir, { withFileTypes: true })
  for (const e of entries) {
    const p = path.join(dir, e.name)
    if (e.isDirectory()) out.push(...(await walk(p)))
    else out.push(p)
  }
  return out
}

function toPosix(p) {
  return p.split(path.sep).join('/')
}

function deriveApiPath(routeFileAbs) {
  const rel = toPosix(path.relative(process.cwd(), routeFileAbs))
  const apiPrefix = 'src/app/api/'
  const idx = rel.indexOf(apiPrefix)
  if (idx === -1) return null
  const tail = rel.slice(idx + apiPrefix.length)
  // tail looks like: "foo/bar/route.ts"
  const withoutFile = tail.replace(/\/route\.(t|j)sx?$/i, '')
  return `/api/${withoutFile}`
}

function extractMethods(source) {
  const methods = new Set()
  const re = /export\s+(?:async\s+)?function\s+(GET|POST|PUT|PATCH|DELETE|HEAD|OPTIONS)\b/g
  let m
  while ((m = re.exec(source))) methods.add(m[1])
  return [...methods].sort()
}

function inferAccess(apiPath, source) {
  const reasons = []

  const hasGetUser = /\.auth\.getUser\s*\(/.test(source)
  const checksUser = /if\s*\(\s*!\s*user\s*\)/.test(source) || /Unauthorized/.test(source)
  const usesServiceClient = /createServiceClient\s*\(/.test(source)

  const isStripeWebhook = /Stripe-Signature/i.test(source) || /webhooks\.constructEvent\s*\(/.test(source)
  const isBankFeedWebhook = /x-ledgerai-webhook-secret/i.test(source) || /x-ledgerai-tenant-api-key/i.test(source)

  const isOauthRoute = apiPath.includes('/oauth/')
  const isOauthCallback = isOauthRoute && apiPath.endsWith('/callback')
  const isOauthStart = isOauthRoute && apiPath.endsWith('/start')

  if (apiPath.startsWith('/api/public/')) {
    reasons.push('path:/api/public/*')
    return { expectedAccess: 'public', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  if (isOauthCallback) {
    reasons.push('oauth callback endpoint (provider redirects here; must validate state/nonce)')
    return { expectedAccess: 'public', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  if (isOauthStart) {
    reasons.push('oauth start endpoint (should be session-protected)')
    return { expectedAccess: 'protected', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  if (isOauthRoute) {
    reasons.push('oauth helper route (default protected unless explicitly designed otherwise)')
    return { expectedAccess: 'protected', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  if (apiPath.startsWith('/api/admin/')) {
    reasons.push('admin endpoint (SUPER_ADMIN only)')
    return { expectedAccess: 'protected', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  if (apiPath === '/api/system/languages') {
    reasons.push('system metadata endpoint')
    return { expectedAccess: 'public', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  if (apiPath === '/api/exchange-rates/cross') {
    reasons.push('mixed: public without tenant_id; auth required with tenant_id')
    return { expectedAccess: 'mixed', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  if (apiPath === '/api/subscriptions/pending/create') {
    reasons.push('mixed: pre-auth signup flow allowed (tenant_id=null); tenant-scoped creation requires auth + membership')
    return { expectedAccess: 'mixed', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  if (isStripeWebhook) {
    reasons.push('stripe webhook signature verification')
    return { expectedAccess: 'webhook', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  if (isBankFeedWebhook) {
    reasons.push('webhook secret / tenant api key auth')
    return { expectedAccess: 'webhook', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  if (hasGetUser && checksUser) {
    reasons.push('auth.getUser + unauthorized gate')
    return { expectedAccess: 'protected', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  // If service-role client is used without an explicit user gate, treat as protected/internal until reviewed.
  if (usesServiceClient && !(hasGetUser && checksUser)) {
    reasons.push('uses service client; ensure internal/privileged access is gated')
    return { expectedAccess: 'protected', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
  }

  reasons.push('default: protect in multi-tenant SaaS')
  return { expectedAccess: 'protected', reasons, signals: { hasGetUser, checksUser, usesServiceClient } }
}

function moduleFromApiPath(apiPath) {
  // /api/admin/... => admin, /api/external-sources/... => external-sources etc
  const parts = apiPath.split('/').filter(Boolean)
  if (parts[0] !== 'api') return 'unknown'
  return parts[1] ?? 'unknown'
}

async function parseMigrationsForTablesAndRpcs() {
  const migrationsDir = path.resolve('supabase/migrations')
  let files = []
  try {
    files = (await walk(migrationsDir)).filter((p) => p.endsWith('.sql'))
  } catch {
    return { tables: [], functions: [] }
  }

  const tables = new Set()
  const functions = new Set()

  const tableRe = /\bcreate\s+table\s+(?:if\s+not\s+exists\s+)?(?:public\.)?([a-zA-Z0-9_]+)/gi
  const fnRe = /\bcreate\s+(?:or\s+replace\s+)?function\s+(?:public\.)?([a-zA-Z0-9_]+)/gi

  for (const f of files) {
    const sql = await fs.readFile(f, 'utf8')
    let m
    while ((m = tableRe.exec(sql))) tables.add(m[1])
    while ((m = fnRe.exec(sql))) functions.add(m[1])
  }

  return {
    tables: [...tables].sort(),
    functions: [...functions].sort(),
  }
}

async function getUiModules() {
  const dir = path.resolve('src/components')
  try {
    const entries = await fs.readdir(dir, { withFileTypes: true })
    return entries.filter((e) => e.isDirectory()).map((e) => e.name).sort()
  } catch {
    return []
  }
}

async function main() {
  const config = await loadPentestConfig().catch(() => ({ output: { inventoryPath: 'security/pentest/inventory.generated.json' } }))
  const inventoryPath = config.output?.inventoryPath ?? 'security/pentest/inventory.generated.json'

  const apiRoot = path.resolve('src/app/api')
  const routeFiles = (await walk(apiRoot)).filter((p) => /\/(?:route\.(t|j)sx?)$/i.test(toPosix(p)))

  const endpoints = []
  for (const abs of routeFiles) {
    const apiPath = deriveApiPath(abs)
    if (!apiPath) continue
    const source = await fs.readFile(abs, 'utf8')
    const methods = extractMethods(source)
    const access = inferAccess(apiPath, source)
    endpoints.push({
      apiPath,
      module: moduleFromApiPath(apiPath),
      file: toPosix(path.relative(process.cwd(), abs)),
      methods,
      ...access,
    })
  }

  const { tables, functions } = await parseMigrationsForTablesAndRpcs()
  const uiModules = await getUiModules()

  const inventory = {
    generatedAt: new Date().toISOString(),
    endpoints: endpoints.sort((a, b) => a.apiPath.localeCompare(b.apiPath)),
    uiModules,
    supabase: { tables, functions },
  }

  await fs.mkdir(path.dirname(path.resolve(inventoryPath)), { recursive: true })
  await fs.writeFile(path.resolve(inventoryPath), JSON.stringify(inventory, null, 2) + '\n', 'utf8')

  console.log(`Wrote inventory: ${inventoryPath}`)
  console.log(`Endpoints: ${inventory.endpoints.length}`)
  console.log(`UI modules: ${inventory.uiModules.length}`)
  console.log(`Supabase tables: ${inventory.supabase.tables.length}`)
  console.log(`Supabase functions: ${inventory.supabase.functions.length}`)
}

main().catch((e) => {
  console.error(e)
  process.exit(1)
})
