import fs from 'node:fs/promises'
import path from 'node:path'
import { loadPentestConfig } from './_config.mjs'

function isPublicEndpoint(apiPath, publicAllowlist) {
  if (apiPath.startsWith('/api/public/')) return true
  return publicAllowlist.includes(apiPath)
}

function expectedPublicFromInventory(ep, publicAllowlist) {
  const expectedAccess = ep?.expectedAccess || 'protected'
  if (expectedAccess === 'public' || expectedAccess === 'webhook' || expectedAccess === 'mixed') return true
  return isPublicEndpoint(ep.apiPath, publicAllowlist)
}

async function safeFetch(url, { method, headers, timeoutMs }) {
  const controller = new AbortController()
  const t = setTimeout(() => controller.abort(), timeoutMs)
  try {
    const res = await fetch(url, { method, headers, redirect: 'manual', signal: controller.signal })
    const contentType = res.headers.get('content-type') || ''
    return {
      ok: res.ok,
      status: res.status,
      contentType,
      headers: {
        'cache-control': res.headers.get('cache-control'),
        'content-security-policy': res.headers.get('content-security-policy'),
        'x-frame-options': res.headers.get('x-frame-options'),
        'x-content-type-options': res.headers.get('x-content-type-options'),
        'referrer-policy': res.headers.get('referrer-policy'),
        'strict-transport-security': res.headers.get('strict-transport-security'),
      },
    }
  } finally {
    clearTimeout(t)
  }
}

async function main() {
  const config = await loadPentestConfig()
  if (!config.probes.enabled) {
    console.log('Probes disabled. Set probes.enabled=true in security/pentest/pentest.config.json')
    return
  }

  const inventoryPath = path.resolve(config.output.inventoryPath)
  const reportPath = path.resolve(config.output.probeReportPath)

  const inventory = JSON.parse(await fs.readFile(inventoryPath, 'utf8'))

  const baseUrl = config.target.baseUrl.replace(/\/$/, '')
  const timeoutMs = config.probes.timeoutMs
  const methods = config.probes.methods
  const publicAllowlist = config.probes.publicAllowlist

  const headers = {
    ...(config.target.headers ?? {}),
  }

  const results = []

  for (const ep of inventory.endpoints ?? []) {
    const apiPath = ep.apiPath
    const url = `${baseUrl}${apiPath}`

    for (const method of methods) {
      // Safe, non-destructive probe: no body.
      let r
      try {
        r = await safeFetch(url, { method, headers, timeoutMs })
      } catch (e) {
        results.push({ apiPath, method, url, error: String(e) })
        continue
      }

      const expectedPublic = isPublicEndpoint(apiPath, publicAllowlist)
      const expectedPublic2 = expectedPublicFromInventory(ep, publicAllowlist)
      const isPreflight = method === 'OPTIONS'

      results.push({
        apiPath,
        module: ep.module,
        method,
        url,
        status: r.status,
        ok: r.ok,
        expectedPublic: expectedPublic2,
        flags: {
          possibleAuthBypass: !expectedPublic2 && !isPreflight && r.ok,
          missingCsp: !r.headers['content-security-policy'],
          missingXcto: !r.headers['x-content-type-options'],
        },
        headers: r.headers,
      })

      // Simple pacing.
      await new Promise((resolve) => setTimeout(resolve, 50))
    }
  }

  const report = {
    generatedAt: new Date().toISOString(),
    target: config.target,
    summary: {
      total: results.length,
      possibleAuthBypass: results.filter((r) => r?.flags?.possibleAuthBypass).length,
    },
    results,
  }

  await fs.mkdir(path.dirname(reportPath), { recursive: true })
  await fs.writeFile(reportPath, JSON.stringify(report, null, 2) + '\n', 'utf8')

  console.log(`Wrote probe report: ${path.relative(process.cwd(), reportPath)}`)
  console.log(`Possible auth bypass findings: ${report.summary.possibleAuthBypass}`)
}

main().catch((e) => {
  console.error(e)
  process.exit(1)
})
